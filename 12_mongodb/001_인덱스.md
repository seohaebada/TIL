# 몽고DB의 인덱스

## 1. 인덱싱 소개

### explain 함수

- 쿼리가 실행될때 몽고DB가 무엇을 하는지 확인할 수 있다.
- explain는 명령을 감싸는 `커서 보조자 메서드(cursor helper method)`와 사용하면 좋다.
  - explain 커서 메서드는 다양한 CRUD 작업의 실행 정보를 제공한다.
  - 이 메서드는 여러가지 장황한 모드(verbosity mode)에서 실행할 수 있다.
```
db.users.find({"username" : "user101"}).explain("executionStats")
```

#### executionStatus 모드
- 인덱스를 이용한 쿼리의 효과를 이해하는데 도움이 된다. 
- "executionStatus" 필드 값
  - "totalDocsExamined" : 몽고DB가 쿼리를 실행하면서 살펴본 도큐먼트 개수
  - "millis" : 쿼리하는데 걸린 시간 (밀리초 단위)
  - "nReturned" : 반환받은 결과의 개수

#### 쿼리 패턴(query pattern)
- 쿼리 패턴 : 단순히 애플리케이션 데이터베이스에 요구하는 다양한 유형의 질문
- 몽고DB가 쿼리에 효율적으로 응답하게 하려면 애플리케이션의 모든 쿼리 패턴에 인덱스를 사용해야한다.
  - ex) 사용자명으로 사용자 컬렉션을 쿼리했다.

### 인덱스 생성

- 인덱스 생성 : `createIndex 컬렉션 메서드` 사용
  ```
  db.users.createIndex({"username" : 1})
  ```
- 인덱스 진행상태 체크 : db.currentOp()
- 인덱스를 생성한 이후, 아래의 쿼리는 거의 즉각적이며, 인덱스 생성 전보다 실행시간이 빠르다.
  ```
  db.users.find({"username" : "user99999"}).explain("executionStats")
  ```
- 인덱스를 생성할 대상 필드를 선택하려면, 자주 쓰는 쿼리와 빨리 수행해야하는 쿼리를 조사해 공통적인 키 셋을 찾아본다.
  - ex) 위에서 "username"으로 쿼리했는데, 이 쿼리가 특히 자주 쓰이거나 병목이 된다면 "username"을 인덱싱하면 좋다.
- 인덱스를 생성하면 아래와 같이 출력된다.
  ```
  [0, "user100020"] -> 8623513776
  ```
  - 각 인덱스 항목은 인덱스 항목을 포함하고, `레코드 식별자(record identifier)`를 가리킨다.
  - 레코드 식별자는 내부에서 스토리지 엔진에 의해 사용되며 도큐먼트 데이터를 찾는다. 
    - [Q] 스토리지 엔진으로 도큐먼트 데이터를 찾는 방식?
  
#### 인덱스 단점
- 인덱싱된 필드를 변경하는 쓰기(삽입, 갱신, 삭제) 작업은 더 오래걸린다.
  - 데이터가 변경될 때마다 도큐먼트뿐 아니라 모든 인덱스를 갱신해야하기 때문이다. 
  - 어떤 필드가 인덱싱하기에 적합한지 신중이 파악해야한다.

### 복합 인덱스

- 복합 인덱스 : 2개 이상의 필드로 구성된 인덱스 
- 예시 상황
인덱스는 모든 값을 정렬된 순서로 보관하므로 인덱스 키로 도큐먼트를 정렬하는 작업이 훨씬 빨라지게 한다.
인덱스가 앞부분에 놓일 때만 정렬에 도움이 된다.
```
db.users.find().sort({"age" : 1, "username" : 1})
```
"username" 인덱스는 다음 정렬에 큰 도움이 되지 않는다. 
명령은 먼저 "age"를 정렬한 후, "username"으로 정렬하는데, "username"에 의한 완전 정렬은 별로 도움이 되지 않는다.
정렬을 최적화하려면 "age"와 "username"에 인덱스를 만든다.
```
db.users.createIndex({"age" : 1, "username" : 1})
```

- 위 상황을 `복합 인덱스`라고 부른다.
- 쿼리에서 정렬 방향이 여러 개이거나 검색 조건에 여러개의 키가 있을때 유용하다.

### 몽고DB가 인덱스를 선택하는 방법

- 5개의 인덱스가 있다고 가정해보자.
  - 1) 쿼리가 들어오면 몽고DB는 쿼리 모양(query shapge)을 확인한다.
    - 쿼리 모양 : 검색할 필드, 정렬 여부 등 추가정보ㄱ와 관련이 있다.
    - 시스템은 이 정보를 기반으로 쿼리를 충족하는데 사용할 인덱스 후보 집합을 식별한다.
  - 쿼리가 들어오고 인덱스 5개 중 3개가 쿼리 후보로 식별됐다고 가정해보자.
    - 각 인덱스 후보에 하나씩 총 3개의 쿼리 플랜을 만든다.
    - 각각 다른 인덱스를 사용하는 3개의 병렬 스레드에서 쿼리를 실행한다.
    - 어떤 스레드에서 가장 빨리 결과를 반환하는지 확인한다.
    - 가장 먼저 목표 상태에 도달하는 쿼리 플랜이 승자가 된다.
      - 모든 쿼리 결과를 가장 먼저 반환하거나, 결과에 대한 시범 횟수를 정렬 순서로 가장 먼저 반환해야한다.
    - 이때 앞으로 동일한 모양을 가진 쿼리에 사용할 인덱스로 선택된다.
    - 플랜은 일정 시간동안 서로 경쟁하며, 위 과정의 결과로 전체 승리 플랜을 산출한다.
- 서버는 쿼리 플랜의 캐시를 유지한다. 승리한 플랜은 차후 모양이 같은 쿼리에 사용하기 위해 캐시에 저장된다.
  - 컬렉션과 인덱스가 시간이 지나 변경되면 쿼리 플랜이 캐시에서 제거된다. 다시 가장 적합한 플랜을 찾는다.
  - 인덱스를 다시 작성하거나, 인덱스를 추가하거나 삭제하면 플랜이 캐시에서 제거된다. 
  - 쿼리 플랜 캐시는 명시적으로 지울 수 있다. 또한 mongod 프로세스를 다시 시작할때도 삭제된다.

### 복합 인덱스 사용

- 읽기와 쓰기를 가능한한 효율적으로 수행하도록 인덱스를 설계하자.
- 인덱스의 선택성(selectivity)을 고려한다.
  - 특정 쿼리 패턴에서 스캔할 레코드 개수를 인덱스가 얼마나 최소화하는지가 중요하다.


> 진행중...