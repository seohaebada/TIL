# 몽고DB의 인덱스

## 1. 인덱싱 소개

### explain 함수

- 쿼리가 실행될때 몽고DB가 무엇을 하는지 확인할 수 있다.
- explain는 명령을 감싸는 `커서 보조자 메서드(cursor helper method)`와 사용하면 좋다.
  - explain 커서 메서드는 다양한 CRUD 작업의 실행 정보를 제공한다.
  - 이 메서드는 여러가지 장황한 모드(verbosity mode)에서 실행할 수 있다.
```
db.users.find({"username" : "user101"}).explain("executionStats")
```

#### executionStatus 모드
- 인덱스를 이용한 쿼리의 효과를 이해하는데 도움이 된다. 
- "executionStatus" 필드 값
  - "totalDocsExamined" : 몽고DB가 쿼리를 실행하면서 살펴본 도큐먼트 개수
  - "millis" : 쿼리하는데 걸린 시간 (밀리초 단위)
  - "nReturned" : 반환받은 결과의 개수

#### 쿼리 패턴(query pattern)
- 쿼리 패턴 : 단순히 애플리케이션 데이터베이스에 요구하는 다양한 유형의 질문
- 몽고DB가 쿼리에 효율적으로 응답하게 하려면 애플리케이션의 모든 쿼리 패턴에 인덱스를 사용해야한다.
  - ex) 사용자명으로 사용자 컬렉션을 쿼리했다.

### 인덱스 생성

- 인덱스 생성 : `createIndex 컬렉션 메서드` 사용
  ```
  db.users.createIndex({"username" : 1})
  ```
- 인덱스 진행상태 체크 : db.currentOp()
- 인덱스를 생성한 이후, 아래의 쿼리는 거의 즉각적이며, 인덱스 생성 전보다 실행시간이 빠르다.
  ```
  db.users.find({"username" : "user99999"}).explain("executionStats")
  ```
- 인덱스를 생성할 대상 필드를 선택하려면, 자주 쓰는 쿼리와 빨리 수행해야하는 쿼리를 조사해 공통적인 키 셋을 찾아본다.
  - ex) 위에서 "username"으로 쿼리했는데, 이 쿼리가 특히 자주 쓰이거나 병목이 된다면 "username"을 인덱싱하면 좋다.
- 인덱스를 생성하면 아래와 같이 출력된다.
  ```
  [0, "user100020"] -> 8623513776
  ```
  - 각 인덱스 항목은 인덱스 항목을 포함하고, `레코드 식별자(record identifier)`를 가리킨다.
  - 레코드 식별자는 내부에서 스토리지 엔진에 의해 사용되며 도큐먼트 데이터를 찾는다. 
    - [Q] 스토리지 엔진으로 도큐먼트 데이터를 찾는 방식?
  
#### 인덱스 단점
- 인덱싱된 필드를 변경하는 쓰기(삽입, 갱신, 삭제) 작업은 더 오래걸린다.
  - 데이터가 변경될 때마다 도큐먼트뿐 아니라 모든 인덱스를 갱신해야하기 때문이다. 
  - 어떤 필드가 인덱싱하기에 적합한지 신중이 파악해야한다.

### 복합 인덱스

- 복합 인덱스 : 2개 이상의 필드로 구성된 인덱스 
- 예시 상황
인덱스는 모든 값을 정렬된 순서로 보관하므로 인덱스 키로 도큐먼트를 정렬하는 작업이 훨씬 빨라지게 한다.
인덱스가 앞부분에 놓일 때만 정렬에 도움이 된다.
```
db.users.find().sort({"age" : 1, "username" : 1})
```
"username" 인덱스는 다음 정렬에 큰 도움이 되지 않는다. 
명령은 먼저 "age"를 정렬한 후, "username"으로 정렬하는데, "username"에 의한 완전 정렬은 별로 도움이 되지 않는다.
정렬을 최적화하려면 "age"와 "username"에 인덱스를 만든다.
```
db.users.createIndex({"age" : 1, "username" : 1})
```

- 위 상황을 `복합 인덱스`라고 부른다.
- 쿼리에서 정렬 방향이 여러 개이거나 검색 조건에 여러개의 키가 있을때 유용하다.

### 몽고DB가 인덱스를 선택하는 방법

- 5개의 인덱스가 있다고 가정해보자.
  - 1) 쿼리가 들어오면 몽고DB는 쿼리 모양(query shapge)을 확인한다.
    - 쿼리 모양 : 검색할 필드, 정렬 여부 등 추가정보ㄱ와 관련이 있다.
    - 시스템은 이 정보를 기반으로 쿼리를 충족하는데 사용할 인덱스 후보 집합을 식별한다.
  - 쿼리가 들어오고 인덱스 5개 중 3개가 쿼리 후보로 식별됐다고 가정해보자.
    - 각 인덱스 후보에 하나씩 총 3개의 쿼리 플랜을 만든다.
    - 각각 다른 인덱스를 사용하는 3개의 병렬 스레드에서 쿼리를 실행한다.
    - 어떤 스레드에서 가장 빨리 결과를 반환하는지 확인한다.
    - 가장 먼저 목표 상태에 도달하는 쿼리 플랜이 승자가 된다.
      - 모든 쿼리 결과를 가장 먼저 반환하거나, 결과에 대한 시범 횟수를 정렬 순서로 가장 먼저 반환해야한다.
    - 이때 앞으로 동일한 모양을 가진 쿼리에 사용할 인덱스로 선택된다.
    - 플랜은 일정 시간동안 서로 경쟁하며, 위 과정의 결과로 전체 승리 플랜을 산출한다.
- 서버는 쿼리 플랜의 캐시를 유지한다. 승리한 플랜은 차후 모양이 같은 쿼리에 사용하기 위해 캐시에 저장된다.
  - 컬렉션과 인덱스가 시간이 지나 변경되면 쿼리 플랜이 캐시에서 제거된다. 다시 가장 적합한 플랜을 찾는다.
  - 인덱스를 다시 작성하거나, 인덱스를 추가하거나 삭제하면 플랜이 캐시에서 제거된다. 
  - 쿼리 플랜 캐시는 명시적으로 지울 수 있다. 또한 mongod 프로세스를 다시 시작할때도 삭제된다.

### 복합인덱스 사용

- 읽기와 쓰기를 가능한한 효율적으로 수행하도록 인덱스를 설계하자.
- 인덱스의 선택성(selectivity)을 고려한다.
  - 특정 쿼리 패턴에서 스캔할 레코드 개수를 인덱스가 얼마나 최소화하는지가 중요하다.

### 복합인덱스 지정이 필요한 상황

- 인덱스를 생성한다.
```
> db.students.createIndex({"class_id" : 1})
> db.students.createIndex({student_id: 1, class_id: 1})
```

- 아래 쿼리를 보자.
```
> db.students.find({student_id:{$gt:500000}, class_id:54})
        .sort({student_id:1})
        .explain("executionStats")
```

- 위 쿼리에서는 ID가 500000보다 큰 모든 레코드를 요청한다. (전체 레코드의 절반 정도)
- 또한 검색을 ID가 54인 클래스에 대한 레코드로 제한한다. (약 500개의 클래스가 있다.)
- 마지막으로 "student_id"를 기준으로 오름차순으로 정렬한다.

> [선정 플랜]
```
...
"winningPlan" : {
  "stage" : "FETCH",
  "inputStage" : {
    "stage" : "IXSCAN",
    "keyPattern" : {
      "student_id" : 1,
      "class_id" : 1
    },
...
```

- 선정된 플랜은 "student_id", "class_id"를 기반으로 복합 인덱스를 사용했다. 
- explain 출력은 쿼리 플랜을 `단계 트리`로 표시한다. 
  - 각 단계에서는 하위 단계 개수에 따라 하나 이상의 입력 단계가 있을 수 있다.
  - 입력 단계는 도큐먼트나 인덱스 키를 상위 단계에 제공한다.
- 예제에서는 입력단계인 인덱스 스캔(IXSCAN)이 1개 있었고, 해당 스캔은 쿼리와 일치하는 도큐먼트에 대한 레코드 ID를 상위단계인 "FETCH" 단계에 제공했다.
- "FETCH" 단계는 도큐먼트를 검색하고 클라이언트가 요청하면 일괄적으로 반환한다. 

> [실패한 플랜]
```
...
"rejectedPlans" : [
  {
    "stage" : "SORT",
    "sortPattern" : {
      "student_id" : 1,
    },
  ...
```

- "class_id"를 기반으로 하는 인덱스를 사용했을 것이다.
- 그러나 이후에 인메모리 정렬을 수행했다.
  - 쿼리 플랜에 "SORT" 단계가 표시된다면, 몽고DB가 데이터베이스 결과 셋을 정렬할때 인덱스를 사용할 수 없었으며, 대신 인메모리를 정렬했다는 뜻이다.
- 실행중인 다중값 쿼리는 "student_id"가 50만보다 큰 레코드를 요청하므로 광범위한 "student_id" 값을 지정한다.

> [결과]
```
"executionStats" : {
  "executionSuccess" : true,
  "nReturn" : 9903,
  "executionTimeMillis" : 4325,
  "totalKeysExamined" : 850477,
  "toptalDocsExamined" : 9903
  ///
}
```

- `totalKeysExamined` : 몽고DB가 결과 셋을 생성하기 위해 인덱스 내에서 몇개의 키를 통과했는지를 나타낸다.
- `totalKeysExamined` 와 `nReturn` 를 비교하면 몽고DB가 쿼리와 일치하는 도큐먼트를 찾기 위해 얼마나 많은 인덱스를 통과했는지 알수있다.
  - 도큐먼트 9903개를 찾으려고 인덱스 키 85만 477개를 검사했다.

> [실행중 쿼리를 다시보자]
```
> db.students.find({student_id:{$gt:500000}, class_id:54})
        .sort({student_id:1})
        .explain("executionStats")
```

- 다중값 부분 : student_id가 50만보다 큰 레코드를 요청하는 부분
- 동등 부분 : class_id가 54인 모든 레코드를 요청하는 부분
  - 동등 부분은 약 500개의 클래스뿐이며, 해당 클래스에 성적이 저장된 학생이 많지만, "class_id"는 이 쿼리를 실행하는데 훨씬 더 선택적인 기준으로 사용된다.
  - "class_id" 값이 결과 셋을 다중값 부분으로 식별된 85만개가 아닌 1만개 미만의 레코드로 제한한다.
- 결과적으로, 실패한 쿼리 플랜에 있는 "class_id"만을 기반으로 인덱스를 사용하는 것이 좋다.

### 복합인덱스 지정

1) 커서 hint 메서드를 사용하여 모양이나 이름을 지정함으로써 사용할 인덱스를 지정할 수 있다.
```
> db.students.find({student_id:{$gt:500000}, class_id:54})
        .sort({student_id:1})
        .hint({class_id:1})
        .explain("executionStats")
```

- 이 경우, 약 85만개의 인덱스 키를 스캔한 것에서 약 2만개로 줄어들어 1만개 미만의 인덱스 키를 얻었다.
- 실행 시간은 4.3초에서 272밀리초로 줄어들었다.


2) 1)번의 방법인 hint 메서드를 사용하지 않고 더 나은 인덱스를 설계하기
- 인덱스 순서를 변경해서 새로 생성하자.
  - "class_id", "student_id"를 기반으로 하는 인덱스다.
  - "class_id"를 접두사로 사용하면 쿼리에서 equality 필터를 사용해 인덱스 내에서 고려되는 키를 제한한다.

```
> db.students.createIndex({class_id:1, student_id:1})
```

- 일반적으로 동등 필터를 사용할 필드가 다중값 필터를 사용할 필드보다 앞에 오도록 복합 인덱스를 설계해야한다.
- 새로운 인덱스 생성 후, 원하던 인덱스를 사용하게된다. ("class_id")

### 위 상황에서 "final_grade"(최종 성적) 필드 기준으로 정렬하는 조건을 추가해보자

```
> db.students.find({student_id:{$gt:500000}, class_id:54})
        .sort({final_grade:1})
        .explain("executionStats")
```

- 쿼리 플랜 결과, "SORT" 단계가 포함된다.
  - 인메모리 정렬이 수행되기 때문에 "student_id"로 정렬했을때보다 훨씬 느리다.
- 인덱스를 더 잘 설계해야 인메모리 정렬을 피할 수 있다.
- 인덱스를 사용해 정렬하려면 몽고DB가 인덱스 키를 순서대로 살펴볼 수 있또록, 복합 인덱스 키 사이에 정렬 필드를 포함해야한다.

```
> db.students.createIndex({class_id:1, final_grade:1, student_id:1})
```

- 정렬 구성 요소는 `동등 필터` 바로 뒤, `다중값 필터` 앞에 포함한다.


### 복합인덱스 설계시 주의할점

- 동등 필터에 대한 키를 맨 앞에 표시해야한다.
- 정렬에 사용되는 키는 다중값 필드 앞에 표시해야한다.
- 다중값 필터에 대한 키는 마지막에 표시해야한다.

- [Q] 조회되는 쿼리 조건은 엄청나게 다양할텐데, 위 조건을 만족하도록하면 인덱스 생성이 엄청 많지 않을까?

<br/>

## 키 방향 선택하기

- 두개(혹은 그 이상)의 검색 조건으로 정렬할 때는 인덱스 키의 방향이 서로 달라야한다.
  - [예시]
  - 나이가 적은 사용자부터 많은 사용자 순으로, 사용자명은 Z부터 A로 컬렉션을 정렬한다고 가정하자.
  - "username"이 A-Z 순서로 정렬되기 때문에 인덱스가 별로 효율적이지 않다.
- 복합 정렬을 서로 다른 방향으로 최적화하려면 방향이 맞는 인덱스를 사용해야한다.

```
{"age" : 1, "username" : -1}
```

- 맞는 방향으로 인덱스를 생성해야한다.
- 인덱스에서 사용할 방향은, 사용 중인 정렬의 방향과 일치시켜보면 파악할 수 있다.
- 역방향 인덱스(각 방향에 -1을 곱한다)는 서로 동등함을 알아두자.
- `{"age" : 1, "username" : -1}, {"age" : -1, "username" : 1}`은 동일한 쿼리를 충족한다.

<br/>

## 커버드 쿼리 사용하기

- 쿼리가 인덱스에 포함된 필드를 찾는중이라면 도큐먼트를 가져올 필요가 없다.
- 인덱스가 쿼리가 요구하는 값을 모두 포함하면, 쿼리가 커버드(covered)된다고 한다.
- 실무에서는 도큐먼트로 되돌아가지말고 항상 커버드 쿼리를 사용하자.
  - 쿼리가 확실히 인덱스만 사용하게 하려면 "_id" 필드를 반환받지 않도록 반환받을 키를 지정해야한다. 
  - 쿼리하지 않은 필드에 인덱스를 만들어야 할 수도 있으므로, 쓰기 때문에 늘어날 부하와 쿼리 속도를 잘 조율해야한다.
- 커버드 쿼리에 explain을 실행하면 결과에 "FETCH" 단계의 하위단계가 아닌 "IXSCAN" 단계가 있으며, "executionStats"에 "totalDocsExamined"의 값이 0이 된다.

<br/>

## 암시적 인덱스

- 복합 인덱스는 '이중 임무'를 수행할 수 있으며 쿼리마다 다른 인덱스처럼 동작할 수 있따.
- `{"age" : 1, "username": 1}`로 인덱스를 가지면 "age" 필드는 `{"age" : 1}`로만 인덱스를 가질때와 동일한 방법으로 정렬된다.
- `{"a" : 1, "b" : 1, "c" : 1, ... "z" : 1}`을 가지면 `{"a" : 1}, {"a" : 1, "b" : 1}, "a" : 1, "b" : 1, "c" : 1}` 등으로 인덱스를 가진다.
- 그 반대로, `{"b" : 1}`이나 `{"a" : 1, "c" : 1}`과 같은 인덱스를 사용하는 쿼리는 최적화되지 않는다.

<br/>

## 비효율적인 인덱스

- 일반적으로 부정 조건은 비효율적이다.
- `$ne` 쿼리 : 인덱스를 사용하긴 하지만 잘 활용되지 못한다. "$ne"로 지정된 항목을 제외한 모든 인덱스 항목을 살펴봐야 하므로 기본적으로 전체 인덱스를 살펴봐야 한다.
  - [예시]
  ```
  > db.example.find({"i" : {"$ne" : 3}}).explain()
  ```
  - 쿼리는 3보다 작은 인덱스 항목과 3보다 큰 인덱스 항목을 모두 조사한다. 거의 컬렉션 전체를 확인해야할 수도 있다.
- `$not` 쿼리 : 기초적인 범위와 정규표현식을 반대로 뒤집을 수도 있다.
  - [예시]
  - `{"key" : {"$lt" : 7}}을 {"key" : {"$gte" : 7}}`로 뒤집을 수 있다.
- `$not`을 사용하는 쿼리 대부분은 테이블 스캔을 수행하고, "$nin"은 항상 테이블 스캔을 수행한다.

<br/>

## 범위

- 복합 인덱스는 몽고DB가 다중 절 쿼리를 더 효율적으로 실행하도록 돕는다. 
- 다중 핅드로 인덱스를 설계할때는 완전 일치가 사용될 필드`("x" : 1)`를 첫번째에, 범위가 사용될 필드 `("Y" : {"$gt" : 3, "$lt" : 5})`를 마지막에 놓자.
- 쿼리가 첫번째 인덱스 키와 정확히 일치하는 값을 찾은 후 두번째 인덱스 범위 안에서 검색하게 해준다. 
- [예시]
  - 특정한 나이와 사용자명의 범위에 `{"age" : 1, "username" : 1}` 인덱스를 사용해 쿼리한다고 가정했을때,
    - "age" : 47은 건너뛰고, 곧이어 "user5" ~ "user8" 사이의 사용자명 범위 내에서 검색한다.
  - 반대로 `{"username" : 1, "age" : 1}` 인덱스를 사용해 쿼리한다고 가정하자.
    - 쿼리가 "user5" ~ "user8" 사이의 사용자를 모두 살펴보고, "age" : 47인 사용자를 뽑아내야하므로 쿼리 플랜을 변경한다.
    - 이전 인덱스를 사용할때의 100배가 되는 인덱스 항목을 살펴보게 된다.

<br/>

## OR 쿼리

- 현재 몽고DB는 쿼리당 하나의 인덱스만 사용할 수 있다.
- {"x" : 1}로 인덱스를 하나 생성하고, {"y" : 1}로 또 다른 인덱스를 생성한 후, {"x" : 123, "y" : 456}으로 쿼리를 실행하면, 둘 중 하나만 사용된다.
- 유일한 예외는 "$or"이다.
  - "$or" : 두개의 쿼리를 수행하고 결과를 합치므로 "$or"은 "$or" 절마다 하나씩 인덱스를 사용할 수 있다.
- 두개의 인덱스상에 있는 분리된 두 쿼리의 집합체다.
```
...
"winningPlan" : {
  "stage" : "SUBPLAN"
  "inputStage" : {
    "stage" : "FETCH",
    "inputStages" : [{
      "stage" : "IXSCAN",
      "keyPattern" : {
      },
     ..
     "inputStages" : [{
      "stage" : "IXSCAN",
      "keyPattern" : {
      },
...
```

- 일반적으로 두번 쿼리해서 결과를 병합하면 한번 쿼리할 때보다 훨씬 비효율적이다. 그러니 "$or" 보다는 "$in"을 사용하자.
- "$or"을 사용해야 한다면 몽고DB가 두 쿼리의 결과를 조사하고 중복을 모두 제거해야함을 명심하자.
- "$in" 쿼리를 실행할때, 정렬을 제외하면 반환되는 도큐먼트의 순서를 제어하는 방법은 없다.
  - `{"x" : {"$in" : [1,2,3]}}`은 `{"x" : {"$in" : [3,2,1]}}`과 동일한 순서로 도큐먼트를 반환한다.

<br/>

## 내장 도큐먼트 인덱싱하기

- 인덱스는 일반적인 키에 생성될 때와 동일한 방식으로 내장 도큐먼트 키를 생성될 수 있다.
```
{
  "username" : "sid",
  "loc" : {
    "ip" : "1.2.3.4",
    "city" : "A",
    "state" : "NY"
  }
}
```

- "loc"의 서브 필드에 인덱스를 만들어 해당 필드를 이용하는 쿼리 속도를 높일 수 있다.
```
> db.users.createIndex({"loc.city" : 1})
```

- 도큐먼트 자체("loc")를 인덱싱하면 내장 도큐먼트의 필드("loc.city")를 인덱싱할 때와는 매우 다르게 동작한다.
- 서브도큐먼트 전체를 인덱싱하면, 서브 도큐먼트 전체에 쿼리할때만 도움이 된다.
  - 도큐먼트 전체가 올바른 필드 순서로 기술된 쿼리에만 "loc" 인덱스를 사용할 수 있다.
    - 인덱스 사용 쿼리 ex) "ip", "city", "state" 순서대로 쿼리
    - 인덱스 사용 불가 쿼리 ex) "loc.city" 로만 쿼리 

<br/>

## 배열 인덱싱하기

- 배열에도 인덱스를 생성할 수 있다. 인덱스를 사용하면 배열의 특정 요소를 효율적으로 찾을 수 있다.
- [예시]
  - 각 도큐먼트가 하나의 게시물인 블로그 게시물 컬렉션이 있다고 가정하자. 각 게시물은 "comments" 필드를 갖는다. ("comment" 서브도큐먼트들로 구성된 배열)
  - 가장 최근에 댓글이 달린 블로그 게시물은 찾으려면?
  - `> db.blog.createIndex({"comments.date" : 1})`
  - 배열을 인덱싱하면 배열의 각 요소에 인덱스 항목을 생성하므로, 한 게시물에 20개의 댓글이 달렸다면 도큐먼트는 20개의 인덱스 항목을 가진다.
  - 따라서 입력, 갱신, 제거 작업을 하려면 모든 배열 요소가 갱신되어야 하므로 배열 인덱스를 단일값 인덱스보다 더 부담스럽게 만든다.
- "loc" 예제와는 달리 배열 전체를 단일 개체처럼 인덱싱 할 수 없다. 
  - 배열 필드 인덱싱은 배열 자체가 아니라 배열의 각 요소를 인덱싱하기 때문이다.
- 배열 요소에 대한 인덱스에는 위치 개념이 없다. 따라서 "comments.4"와 같이 특정 배열 요소를 찾는 쿼리에는 인덱스를 사용할 수 없다.
- 배열의 특정 항목에 인덱스를 생성할 수는 있다.
  - `> db.blog.createIndex({"comments.10.votes" : 1})`
    - 11번째 배열 요소를 쿼리할때만 유용하다.
- 인덱스 항목의 한 필드만 배열로부터 가져올 수 있다.
  - 여러 다중키 인덱스에 의해 인덱스 항목이 폭발적으로 늘어나는 것을 피하기 위함이다.
  - 가능한 요소 쌍이 모두 인덱싱되므로 도큐먼트마다 n*m개의 인덱스 항목이 생긴다.
    - {"x" : 1, "y" : 1}로 인덱스가 만들어져 있다고 가정하자.
    ```
    // x 가 배열 - 정상
    > db.multi.insert({"x" : [1,2,3], "y" : 1})
    
    // y 가 배열 - 정상
    > db.multi.insert({"x" : 1, "y" : [4,5,6]]})
    
    // x, y가 배열 - 비정상
    > db.multi.insert({"x" : [1,2,3], "y" : [4,5,6]})
    cannot index parallel arrays[y][x]
    ```
    - 마지막 비정상인 경우를 보자.
    - 인덱스 항목을 (1,4), (1,5), (1,6), (2,4), (2,5)... 등 n*m개가 생성되어야한다.

<br/>

## 다중키 인덱스가 미치는 영향

- 어떤 도큐먼트가 배열 필드를 인덱스 키로 가지면 인덱스는 즉시 다중키 인덱스로 표시된다.
- 다중키 인덱스가 사용됬다면 "isMultiKey" 필드는 true다.
- 인덱스는 일단 다중키로 표시되면 필드 내 배열을 포함하는 도큐먼트가 모두 제거되더라도 비다중키가 될 수 없다.
  - 비다중키가 되게 하려면 인덱스를 삭제하고 다시 생성해야만 한다.
- 다중키 인덱스는 비다중키 인덱스보다 약간 느릴 수 있다. 하나의 도큐먼트를 여러개의 인덱스 항목이 가리킬 수 있으므로, 몽고DB는 결과를 반환하기 전에 중복을 제거해야한다.
  - [Q] 하나의 도큐먼트를 여러개의 인덱스 항목이 가리킨다는건 어떤 의미?

<br/>

## 인덱스 카디널리티 
  
- 카디널리티(cadinality) : 컬렉션의 한 필드에 대한 고윳값이 얼마나 많은지를 나타낸다.
  - 높은 카디널리티 : "username", "email"과 같은 각 도큐먼트마다 유일한 값을 가지는 필드 
  - 낮은 카디널리티 : "gender"과 같은 가질 수 있는 값이 2가지뿐인 필드
  - 중간 카디널리티 : "age"나 "zip code"와 같은 필드
- 일반적으로 필드의 커디널리티가 높을수록 인덱싱이 더욱 도움이 된다. 인덱스가 검색 범위를 훨씬 작은 결과 셋으로 빠르게 좁힐 수 있기 때문이다.
- 일반적으로 낮은 카디널리티 필드에서 인덱스는 높은 카디널리티 필드에서만큼 일치하는 항목을 많이 제거할 수 없다.
- 일반적으로 높은 카디널리티 키를 생성하면 좋다. 적어도 복합 인덱스에서는 높은 카디널리티 키를 낮은 카디널리티 키보다 앞에 놓자.

